//#include "Mandelbrot.h"
//#include "MandelbrotMath.h"
//
//#include <iostream>
//#include <omp.h>
//#include "OmpTools.h"
//
//#include "IndiceTools_GPU.h"
//using cpu::IndiceTools;
//
//using std::cout;
//using std::endl;
//
///*----------------------------------------------------------------------*\
// |*			Declaration 					*|
// \*---------------------------------------------------------------------*/
//
///*--------------------------------------*\
// |*		Imported	 	*|
// \*-------------------------------------*/
//
//extern __global__ void mandelbrot(uchar4* ptrDevPixels, uint w, uint h, float t);
//
///*--------------------------------------*\
// |*		Public			*|
// \*-------------------------------------*/
//
///*--------------------------------------*\
// |*		Private			*|
// \*-------------------------------------*/
//
///*----------------------------------------------------------------------*\
// |*			Implementation 					*|
// \*---------------------------------------------------------------------*/
//
///*--------------------------------------*\
// |*		Public			*|
// \*-------------------------------------*/
//Mandelbrot::Mandelbrot(const Grid& grid, uint w, uint h, int N, const DomaineMath& domaineMath) :
//		Animable_I<uchar4>(grid, w, h, "Mandelbrot_Cuda_rgba_uchar4",domaineMath), variateurAnimation(Interval<int>(20, N), 1)
//	    {
//	    // Tools
//	    this->t = 0;					// protected dans super classe Animable
//	    this->parallelPatern = ParallelPatern::OMP_MIXTE;   // protected dans super classe Animable
//
//	    // OMP
//	    cout << "\n[Mandelbrot] : Cuda : nbThread = " << this->nbThread << endl; // protected dans super classe Animable
//	    }
//
//Mandelbrot::~Mandelbrot(void)
//    {
//    // rien
//    }
///*--------------------------------------*\
// |*		Public			*|
// \*-------------------------------------*/
///**
// * Override
// */
//void Mandelbrot::animationStep()
//    {
//    this->t = variateurAnimation.varierAndGet(); // in [0,2pi]
//    }
///*--------------------------------------*\
// |*		Private			*|
// \*-------------------------------------*/
//
///**
// * Override (code entrainement cuda)
// */
//void Mandelbrot::process(uchar4* ptrDevPixels, uint w, uint h, const DomaineMath& domaineMath)
//    {
//    Device::lastCudaError("rippling rgba uchar4 (before kernel)"); // facultatif, for debug only, remove for release
//
//    // lancer le kernel avec <<<dg,db>>>
//    // le kernel est importer ci-dessus (ligne 19)
//    mandelbrot<<<dg, db>>>(ptrDevPixels, w, h, t);
//
//    Device::lastCudaError("rippling rgba uchar4 (after kernel)"); // facultatif, for debug only, remove for release
//
////    MandelbrotMath mandelbrotMath(this->t); // ici pour preparer cuda
////
////    const int WH = w * h;
////
////#pragma omp parallel
////	{
////	const int NB_THREAD = OmpTools::getNbThread(); // dans region parallel
////	const int TID = OmpTools::getTid();
////
////	int i;
////	int j;
////
////	int s = TID; // in [0,...
////	while (s < WH)
////	    {
////	    IndiceTools::toIJ(s, w, &i, &j); // s[0,W*H[ --> i[0,H[ j[0,W[
////
////	    workPixel(&ptrTabPixels[s],i,j,domaineMath,&mandelbrotMath);
////
////	    s += NB_THREAD;
////	    }
////	}
//    }
//
///*--------------------------------------*\
// |*		Private			*|
// \*-------------------------------------*/
//
///**
// * i in [0,h[
// * j in [0,w[
// *
// * code commun a:
// * 	- entrelacementOMP
// * 	- forAutoOMP
// */
//void Mandelbrot::workPixel(uchar4* ptrColorIJ,int i, int j,const DomaineMath& domaineMath,MandelbrotMath* ptrMandelbrotMath)
//    {
//    // (i,j) domaine ecran dans N2
//    // (x,y) domaine math dans R2
//
//    double x;
//    double y;
//    domaineMath.toXY(i, j, &x, &y); // fill (x,y) from (i,j)
//
//   // float t=variateurAnimation.get();
//
//    ptrMandelbrotMath->colorXY(ptrColorIJ,x, y, t); // in [01]
//    }
///*----------------------------------------------------------------------*\
// |*			End	 					*|
// \*---------------------------------------------------------------------*/
//
